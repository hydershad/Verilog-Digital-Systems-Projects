`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 04/25/2018 07:07:49 PM
// Design Name: 
// Module Name: top
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


// You can use this skeleton testbench code, the textbook testbench code, or your own

module Complete_MIPS(CLK,switchinput,seg, l, r, an);
  // Will need to be modified to add functionality
  input CLK;
  parameter [27:0] displayclockvalue = 28'b0000000000011010000100100000; 
  input [2:0] switchinput; 
  wire systemclock; 
  output [6:0] seg; 
  input l; 
  input r;
//  wire nl;
//  wire nr;
//  wire btn; 
//  wire btnr;
  output reg [3:0] an; 
  reg [15:0] displayvalue; 
  reg [3:0] displayin; 
  wire displayclock;
  wire millisecclk; 
  
    wire CS, WE;
    wire [6:0] ADDR;
    wire [31:0] Mem_Bus;
    wire [15:0] upperreg2;
    wire [15:0] upperreg3;
    wire [15:0] lowerreg2;
    wire [15:0] lowerreg3;
  
  complexDivider dispclock(CLK, displayclockvalue, displayclock);   
  bcd_seven segdisp(displayin, seg); 
  
    MIPS CPU(CLK, CS, WE, ADDR, Mem_Bus, lowerreg2, lowerreg3, upperreg2, upperreg3, switchinput);
    Memory MEM(CS, WE, CLK, ADDR, Mem_Bus);
   
    
  reg [2:0] dispstate; 
  initial
  begin
  dispstate = 0; 
  displayvalue = 0; 
  end
  
  always @(*) //combinational
  begin
  if(switchinput == 0)
  begin
  if(l == 0 && r == 0) displayvalue <= lowerreg2; 
  else if(l == 0 && r == 1) displayvalue <= upperreg2; 
  else if(l == 1 && r == 0) displayvalue <= lowerreg3; 
  else displayvalue <= upperreg3;
  end 
  else if(switchinput == 1 || switchinput == 2 || switchinput == 3 || switchinput == 4 || switchinput == 5 || switchinput == 6 )
  begin
  if(l == 0 && r == 0) displayvalue <= lowerreg2; 
  else if(l == 0 && r == 1) displayvalue <= upperreg2; 
  else displayvalue <= 0;
  end 
  else displayvalue <= 0;
  end
  
  
  always @(posedge displayclock) 
  begin
  if(dispstate == 0) dispstate <= 1; 
  else if(dispstate == 1) dispstate <= 2; 
  else if(dispstate == 2) dispstate <= 3; 
  else dispstate <= 0; 
  end
  
  always @(*)
  begin 
  if(dispstate == 0) 
  begin
  displayin <= displayvalue[3:0];
  an[0] <= 0; 
  an[1] <= 1;
  an[2] <= 1;
  an[3] <= 1; 
  end 
  else if(dispstate == 1) 
  begin
  displayin <= displayvalue[7:4];
  an[0] <= 1; 
  an[1] <= 0;
  an[2] <= 1;
  an[3] <= 1; 
  end  
  else if(dispstate == 2) 
  begin
  displayin <= displayvalue[11:8];
  an[0] <= 1; 
  an[1] <= 1;
  an[2] <= 0;
  an[3] <= 1; 
  end  
  else
  begin
  displayin <= displayvalue[15:12];
  an[0] <= 1; 
  an[1] <= 1;
  an[2] <= 1;
  an[3] <= 0;
  end
  end

endmodule

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

module Memory(CS, WE, CLK, ADDR, Mem_Bus);
  input CS;
  input WE;
  input CLK;
  input [6:0] ADDR;
  inout [31:0] Mem_Bus;

  reg [31:0] data_out;
  reg [31:0] RAM [0:127];
  integer i; 
  reg [6:0] counter; 

  initial
  begin
    for(i=0; i< 128; i= i+1)
    begin
        RAM[i] = 32'd0;
    end
  $readmemb("MIPS_Instructions.txt", RAM); 
  end

  assign Mem_Bus = ((CS == 1'b0) || (WE == 1'b1)) ? 32'bZ : data_out;

  always @(negedge CLK)
  begin

    if((CS == 1'b1) && (WE == 1'b1))
      RAM[ADDR] <= Mem_Bus[31:0];

    data_out <= RAM[ADDR];
  end
endmodule

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

module REG(CLK, RegW, DR, SR1, SR2, Reg_In, switchinput, ReadReg1, ReadReg2, lowerreg2, lowerreg3, upperreg2, upperreg3);
  input CLK;
input RegW;
input [4:0] DR;
input [4:0] SR1;
input [4:0] SR2;
input [31:0] Reg_In;
input [2:0] switchinput;
output reg [31:0] ReadReg1;
output reg [31:0] ReadReg2;

  output reg[15:0] lowerreg2; 
  output reg[15:0] lowerreg3; 
  output reg[15:0] upperreg2; 
  output reg[15:0] upperreg3;
reg [31:0] REG [0:31];
integer i;


initial begin
for(i=0;i<32;i = i+1)REG[i]= 0;
  ReadReg1 = 0;
  ReadReg2 = 0;
end

always @(posedge CLK)
begin

  if(RegW == 1'b1)
    REG[DR] <= Reg_In[31:0];
    REG[1] <= switchinput;
  ReadReg1 <= REG[SR1];
  ReadReg2 <= REG[SR2];
  
     lowerreg2 <= REG[2][15:0];
   lowerreg3 <= REG[3][15:0];
   upperreg2 <= REG[2][31:16];
   upperreg3 <= REG[3][31:16];
end
endmodule


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

`define opcode instr[31:26]
`define sr1 instr[25:21]
`define sr2 instr[20:16]
`define f_code instr[5:0]
`define numshift instr[10:6]

module MIPS(CLK, CS, WE, ADDR, Mem_Bus, lowerreg2, lowerreg3, upperreg2, upperreg3, switchinput);
  input CLK;
  input[2:0] switchinput;
  output reg CS, WE;
  output [6:0] ADDR;
  inout [31:0] Mem_Bus;
  output [15:0] upperreg2;
    output [15:0] upperreg3;
    output [15:0] lowerreg2;
    output [15:0] lowerreg3;

    wire [31:0] reg2;
    wire [31:0] reg3;

  //special instructions (opcode == 000000), values of F code (bits 5-0):
  parameter add = 6'b100000;
    parameter sub = 6'b100010;
    parameter xor1 = 6'b100110;
    parameter and1 = 6'b100100;
    parameter or1 = 6'b100101;
    parameter slt = 6'b101010;
    parameter srl = 6'b000010;
    parameter sll = 6'b000000;
    parameter jr = 6'b001000;
  
    //non-special instructions, values of opcodes:
    parameter addi = 6'b001000;
    parameter andi = 6'b001100;
    parameter ori = 6'b001101;
    parameter lw = 6'b100011;
    parameter sw = 6'b101011;
    parameter beq = 6'b000100;
    parameter bne = 6'b000101;
    parameter j = 6'b000010;
  
    //new instructions (opcode is not 0)
    parameter jal = 6'b000011;
    parameter lui = 6'b001111;
    
    //new instructions (opcode is 0 and the last bits have the opcode)
    parameter mult = 6'b011000;
    parameter mfhi = 6'b010000;
    parameter mflo = 6'b010010;
    parameter add8 = 6'b101101;
    parameter rbit = 6'b101111;
    parameter rev = 6'b110000;
    parameter sadd = 6'b110001;
    parameter ssub = 6'b110010;
    
    //instruction format
    parameter R = 2'd0;//the last bits are the opcode F-code
    parameter I = 2'd1;//other instructions with adress/immediate
    parameter J = 2'd2;//with target address liek jump
  
    //internal signals
    reg [5:0] op, opsave; //operation select
    wire [1:0] format;//indication of the instruction R,I,J
    reg [31:0] instr, alu_result;//instr: current instruction; alu_result: Output of ALU
    wire [31:0] hi,lo;//32 bits splitting for 64 bit outputs
    reg [63:0] prod; //64 bits product 
    reg [6:0] pc, npc; //program counter
    wire [31:0] imm_ext, alu_in_A, alu_in_B, reg_in, readreg1, readreg2; 
    //imm_ext : sign extended immediate constant
    //alu_in_A: First Operand
    //alu_in_B
    //reg_in: Data input to registers
    //regreg: source registers
    
    reg [31:0] alu_result_save;
    reg alu_or_mem, alu_or_mem_save, regw, writing, reg_or_imm, reg_or_imm_save;
    reg fetchDorI;
    wire [4:0] dr;
    reg [2:0] state, nstate;
  
    integer i;
    //combinational
    assign imm_ext = (instr[15] == 1)? {16'hFFFF, instr[15:0]} : {16'h0000, instr[15:0]};//Sign extend immediate field
    assign dr = (format == R)? ((`f_code == rbit || `f_code == rev)? instr [25:21] : instr[15:11])  : ((format == J)? 5'd31 : instr[20:16]); //Destination Register MUX (MUX1)
    assign alu_in_A =  readreg1;
    assign alu_in_B = (reg_or_imm_save)? imm_ext : readreg2; //ALU MUX (MUX2)
    assign reg_in = (alu_or_mem_save)? Mem_Bus : alu_result_save; //Data MUX
    assign format = (`opcode == 6'd0)? R : ((`opcode == 6'd2 || `opcode == 6'd3)? J : I);
    assign Mem_Bus = (writing)? readreg2 : 32'bZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ;
    assign hi = prod[63:32];
    assign lo = prod[31:0];
    
  
  wire [6:0] jalvalue; 
    assign jalvalue = pc; //for return
    //drive memory bus only during writes
    assign ADDR = (fetchDorI)? pc : alu_result_save[6:0]; //ADDR Mux
    REG Register(CLK, regw, dr, `sr1, `sr2, reg_in, switchinput, readreg1, readreg2, lowerreg2, lowerreg3, upperreg2, upperreg3);
  
    initial begin
      op = and1; opsave = and1;
      state = 3'b0; nstate = 3'b0;
      alu_or_mem = 0;
      regw = 0;
      fetchDorI = 0;
      writing = 0;
      reg_or_imm = 0; reg_or_imm_save = 0;
      alu_or_mem_save = 0;
      
  
    end
  
    always @(*)
    begin
     fetchDorI = 0; CS = 0; WE = 0; regw = 0; writing = 0; alu_result = 32'd0;
      npc = pc; op = jr; reg_or_imm = 0; alu_or_mem = 0; nstate = 3'd0;
      
      case (state)
        0: begin //fetch
          npc = pc + 7'd1; CS = 1; nstate = 3'd1;
          fetchDorI = 1;
        end
         1: begin //decode
          nstate = 3'd2; reg_or_imm = 0; alu_or_mem = 0;
          if (format == J) begin
           if(`opcode == j) begin //jump, and finish
              npc = instr[6:0];
              nstate = 3'd0;
            end
            else if (`opcode == jal) begin
              nstate = 3'd2;
              op = jal;
            end
          end
         else if (format == R) //register instructions
            op = `f_code;
          else if (format == I) begin //immediate instructions
            reg_or_imm = 1;
            if(`opcode == lw) begin
              op = add;
              alu_or_mem = 1;
            end
            else if ((`opcode == lw)||(`opcode == sw)||(`opcode == addi)) op = add;
            else if ((`opcode == beq)||(`opcode == bne)) begin
              op = sub;
              reg_or_imm = 0;
            end
            else if (`opcode == andi) op = and1;
            else if (`opcode == ori) op = or1;
            else if (`opcode == lui) op = lui;
          end
        end
        2: begin //execute
          nstate = 3'd3;
          if (opsave == and1) alu_result = alu_in_A & alu_in_B;
          else if (opsave == or1) alu_result = alu_in_A | alu_in_B;
          else if (opsave == add) alu_result = alu_in_A + alu_in_B;
          else if (opsave == sub) alu_result = alu_in_A - alu_in_B;
          else if (opsave == srl) alu_result = alu_in_B >> `numshift;
          else if (opsave == sll) alu_result = 32'd0 | alu_in_B << `numshift;
          else if (opsave == slt) alu_result = (alu_in_A < alu_in_B)? 32'd1 : 32'd0;
          else if (opsave == xor1) alu_result = alu_in_A ^ alu_in_B;
//          else if (opsave == mult) //prod = alu_in_A * alu_in_B;
//      begin
  
//  end 
          else if(opsave == mult) ;//prod = alu_in_A [15:0] * alu_in_B [15:0] ; 
          else if (opsave == mfhi) alu_result = hi;
          else if (opsave == mflo) alu_result = lo; 
          else if (opsave == ssub) begin
                  if((alu_in_A < alu_in_B)) alu_result = 0;
                  else alu_result = alu_in_A - alu_in_B;
                end
          else if (opsave == sadd) begin
                  if((alu_in_A + alu_in_B) > 32'hFFFFFFFF) alu_result = (32'hFFFFFFFF - 1);
                  else alu_result = alu_in_A + alu_in_B;
                end
          else if (opsave == rev) begin
                  alu_result[31:24] = alu_in_B[7:0];
                  alu_result[23:16] = alu_in_B[15:8];
                  alu_result[15:8] = alu_in_B[23:16];
                  alu_result[7:0] = alu_in_B[31:24];
                end
          else if (opsave == add8) begin
                  alu_result[31:24] = alu_in_A[31:24] + alu_in_B[31:24];
                  alu_result[23:16] = alu_in_A[23:16] + alu_in_B[23:16];
                  alu_result[15:8] = alu_in_A[15:8] + alu_in_B[15:8];
                  alu_result[7:0] = alu_in_A[7:0] + alu_in_B[7:0];
                end
          else if (opsave == lui) begin
                  alu_result = alu_in_B << 16;
                end
      else if(opsave == jal) begin
              alu_result = 32'd0 | jalvalue;
          end 
          else if (opsave == rbit) begin
                for(i=0;i<32;i=i+1) begin
                    alu_result[i]= alu_in_B[31-i];
                  end
                end
                end
        3: begin //prepare to write to mem
          nstate = 3'd0;
          if ((format == R)||(`opcode == addi)||(`opcode == andi)||(`opcode == ori) || (`opcode == rbit) || (`opcode == rev ) || (`opcode == sadd) || (`opcode == ssub))  regw = 1;
          else if (`opcode == sw) begin
            CS = 1;
            WE = 1;
            writing = 1;
          end
      else if(`opcode == lui) 
  begin
  regw = 1; 
  end
  else if(`opcode == jal)
  begin
  regw = 1; 
  nstate = 3'b100; 
  end
          else if (`opcode == lw) begin
            CS = 1;
            nstate = 3'd4;
          end
        end
        
        4: begin
          nstate = 3'd0;
          CS = 1;
          if (`opcode == lw) regw = 1;
  else if(`opcode == jal) npc = instr[6:0];
        end
      endcase
    end //always
  
   always @(posedge CLK) begin
  
      //if (RST) begin
        //state <= 3'd0;
        //pc <= 7'd0;
      //end
      //else begin
        state <= nstate;
        pc <= npc;
 //     end
  
      if (state == 3'd0) instr <= Mem_Bus;
      else if (state == 3'd1) begin
        opsave <= op;
        reg_or_imm_save <= reg_or_imm;
        alu_or_mem_save <= alu_or_mem;
      end
      else if (state == 3'd2) 
      begin
      alu_result_save <= alu_result;
  if(`f_code == mult) prod = alu_in_A * alu_in_B; 
  end

  end //always

endmodule

module complexDivider(clk100Mhz, clockvalue , slowClk);
  input clk100Mhz; //fast clock
  output reg slowClk; //slow clock
  input [27:0] clockvalue; 
  reg[27:0] counter;

  initial begin
    counter = 0;
    slowClk = 0;
  end

  always @ (posedge clk100Mhz)
  begin
    if(counter == clockvalue) begin
      counter <= 1;
      slowClk <= ~slowClk;
    end
    else begin
      counter <= counter + 1;
    end
  end

endmodule 


module bcd_seven (bcd,seven);
  input[3:0] bcd;
  output[7:1] seven;
  
  reg [7:1] seven;
  
  always @(bcd)
  begin
    case(bcd)
      4'b0000 : seven = 7'b1000000; 
      4'b0001 : seven = 7'b1111001; 
      4'b0010 : seven = 7'b0100100; 
      4'b0011 : seven = 7'b0110000; 
      4'b0100 : seven = 7'b0011001; 
      4'b0101 : seven = 7'b0010010; 
      4'b0110 : seven = 7'b0000010; 
      4'b0111 : seven = 7'b1111000; 
      4'b1000 : seven = 7'b0000000;
      4'b1001 : seven = 7'b0010000; 
      4'b1010 : seven = 7'b0001000; 
      4'b1011 : seven = 7'b0000011; 
      4'b1100 : seven = 7'b1000110; 
      4'b1101 : seven = 7'b0100001; 
      4'b1110 : seven = 7'b0000110; 
      4'b1111 : seven = 7'b0001110; 
      default : seven = 7'b1111111;
    endcase
  end
endmodule

